<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>BPMN Diagram Converter</title>
    <link rel="icon" type="image/png" href="/images/favicon.png">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.1/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-iYQeCzEYFbKjA/T2uDLTpkwGzCiq6soy8tYaI1GyVh/UjpbCx/TYkiZhlZB6+fzT" crossorigin="anonymous">

    <!-- required viewer styles -->
    <link rel="stylesheet" href="https://unpkg.com/bpmn-js@10.2.1/dist/assets/bpmn-js.css">
    
    <link rel="stylesheet" href="styles/viewer.css">

    <!-- viewer distro (with pan and zoom) -->
    <script src="https://unpkg.com/bpmn-js@10.2.1/dist/bpmn-navigated-viewer.development.js"></script>
<!--     <script src="https://unpkg.com/bpmn-js@10.2.1/dist/bpmn-modeler.development.js"> -->

    <!-- needed for this example only -->
    <script src="https://unpkg.com/jquery@3.3.1/dist/jquery.js"></script>

</head>
<body>
<div class="container-fluid">
    <h1>BPMN Diagram Converter</h1>
    <div class="alert alert-primary" role="alert">
        <h6>Legal disclaimer</h6>
        <p class="small m-0">Each user retains the intellectual property rights it has created prior to accessing the
            BPMN Diagram
            Converter in connection to process models, studies or other materials of its own, uploaded on the BPMN
            Diagram Converter.</p>
        <p class="small m-0">The uploaded data in its complete context will not be saved or processed for other purposes
            than converting your process diagram.</p>
        <p class="small m-0">Technical problems that might occur will be sent to the administrator. The contained
            information will provide no insights on the full document.</p>
        <p class="small m-0">Through conversion, the behavior of your process diagram might change. Please review and
            test any converted diagram.</p>
    </div>
    <div class="row">
        <div class="mb-3">
            <label for="formFile" class="form-label">Camunda 7 BPMN files</label>
            <input class="form-control" type="file" id="formFile" multiple>
        </div>
        <div class="mb-3">
            <input class="form-check-input" type="checkbox" id="appendDocumentation">
            <label for="appendDocumentation"
                   class="form-check-label">Append
                messages to documentation</label>
        </div>
        <div class="mb-3">
            <button type="button" class="btn btn-primary" id="check">Check</button>
            <button type="button" class="btn btn-primary" id="convert">Convert and download</button>
            <button type="button" class="btn btn-primary" id="downloadCsv">Download Checklist as CSV</button>
        </div>
    </div>
    <div class="row">
        <div class="mb-3">
            <div id="canvas"></div>        
        </div>
    </div>
    <div class="accordion" id="accordionExample" hidden>

        <div class="accordion-item">
            <h2 class="accordion-header" id="headingTwo">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse"
                        data-bs-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
                    Arranged results
                </button>
            </h2>
            <div id="collapseTwo" class="accordion-collapse collapse" aria-labelledby="headingTwo"
                 data-bs-parent="#accordionExample">
                <div class="accordion-body" id="arrangedResults">

                </div>
            </div>
        </div>
        <div class="accordion-item">
            <h2 class="accordion-header" id="headingOne">
                <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne"
                        aria-expanded="true" aria-controls="collapseOne">
                    Raw results
                </button>
            </h2>
            <div id="collapseOne" class="accordion-collapse collapse" aria-labelledby="headingOne"
                 data-bs-parent="#accordionExample">
                <div class="accordion-body">
                    <div class="text-bg-dark rounded">
                        <pre id="checkContainer"></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.1/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-u1OknCvxWvY5kfmNBILK2hRnQC3Pr17a+RTT6rIHI7NnikvbZlHgTPOOmMi466C8"
        crossorigin="anonymous"></script>
<script>
    const check = document.getElementById("check");
    const convert = document.getElementById("convert");
    const downloadCsv = document.getElementById("downloadCsv");

    const fileUpload = document.getElementById("formFile");
    const appendDocumentation = document.getElementById("appendDocumentation");

    const checkContainer = document.getElementById("checkContainer");
    const resultArea = document.getElementById("accordionExample");
    const arrangedResultsArea = document.getElementById("arrangedResults");

    const severityClasses = {
        "WARNING": "text-bg-danger",
        "INFO": "text-bg-info",
        "TASK": "text-bg-secondary"
    }

    const el = (tagName, attributes, children) => {
        const element = document.createElement(tagName);
        Object.keys(attributes).forEach(key => element[key] = attributes[key]);
        element.append(...children);
        return element;
    };

    const createFormattedResult = result => {
        if (result.messages.length) {
            return el("div", {className: "card m-3"}, [
                el("div", {className: "card-header"}, [result.elementType + " ", el("code", {}, result.elementId), ` ${result.elementName || ""}`]),
                createFormattedMessages(result.messages)
            ]);
        }
    };

    const createFormattedMessages = messages => {
        return el("ul", {className: "list-group list-group-flush"}, messages.map(createFormattedMessage));
    };

    const createFormattedMessage = message => {
        return el("li", {className: `list-group-item ${severityClasses[message.severity]}`}, `${message.severity}: ${message.message}`);
    };

    const createFormData = async () => {
        const formData = new FormData();
        if (fileUpload.files.length === 0) {
            alert("Please select a .bpmn file");
            return null;
        }
        for (let i = 0; i < fileUpload.files.length; i++) {
            formData.append("files", fileUpload.files[i], fileUpload.files[i].name)
        }
        formData.append("appendDocumentation", appendDocumentation.checked)
        return formData;
    }
    const createFormattedResultWrapper = files => {
        arrangedResultsArea.append(...files.map(createFormattedResultForFile));
    }

    const createFormattedResultForFile = file => {
        return el("div", {className: "card mb-3"}, [
            el("div", {className: "card-header"}, [file.filename]),
            el("ul", {className: "list-group list-group-flush"}, file.results.map(createFormattedResult).filter(e => e !== undefined))
        ]);

    }

    const downloadResponse = async response => {
        const contentDisposition = response.headers.get("Content-Disposition");
        const targetFileName = contentDisposition.substring(contentDisposition.indexOf("\"") + 1, contentDisposition.lastIndexOf("\""));
        response.blob().then(data => {
            const a = document.createElement("a");
            a.href = window.URL.createObjectURL(data);
            a.download = targetFileName;
            a.click();
        });
    };

    check.addEventListener("click", async () => {
        const formData = await createFormData();
        if (!formData) {
            return;
        }
        fetch("/check", {
            body: formData,
            method: "POST",
            headers: {
            	  "Accept": "application/json"
            }
        }).then(response => {
            response.json().then(json => {
                checkContainer.innerHTML = JSON.stringify(json, null, 2);
                arrangedResultsArea.innerHTML = "";
                createFormattedResultWrapper(json);
                resultArea.hidden = false;
            })
        });
    });

    downloadCsv.addEventListener("click", async () => {
        const formData = await createFormData();
        if (!formData) {
            return;
        }
        fetch("/check", {
            body: formData,
            method: "POST",
            headers: {
                "Accept": "text/csv"
            }
        }).then(downloadResponse);
    });

    convert.addEventListener("click", async () => {
        const formData = await createFormData();
        if (!formData) {
            return;
        }
        fetch("/convert", {
            body: formData,
            method: "POST"
        }).then(downloadResponse);
    });
    
    
//     async function getCamundaModdle() {
//         try {
//             const response = await fetch('https://unpkg.com/camunda-bpmn-moddle@7.0.1/resources/camunda.json')
//             if (!response.ok) {
//                 throw new Error(`HTTP Error: ${response.status}`)
//             }
//             const data = await response.json();
//             return data;
//         }
//         catch (error) {
//             console.error(`could not get Camunda moddle: ${error}`);
//         }
//     } 
    
//     const promise = getCamundaModdle();
//     promise.then(data => CamundaModdle = data);
    
//     console.log('Camunda Moddle: ', CamundaModdle)
    
    // viewer instance
    var bpmnViewer = new BpmnJS({
      container: '#canvas',
//       moddleExtension: {
//           camunda: CamundaModdle
//       }
    });

    /**
     * Open diagram in our viewer instance.
     *
     * @param {String} bpmnXML diagram to display
     */
    async function openDiagram(bpmnXML) {

      // import diagram
      try {

        await bpmnViewer.importXML(bpmnXML.target.result);

        // access viewer components
        var canvas = bpmnViewer.get('canvas');
        var overlays = bpmnViewer.get('overlays');
        var elementRegistry = bpmnViewer.get('elementRegistry');

        // zoom to fit full viewport
        canvas.zoom('fit-viewport');

        // attach an overlay to a node
//         overlays.add('SCAN_OK', 'note', {
//           position: {
//             bottom: 0,
//             right: 0
//           },
//           html: '<div class="diagram-note">Mixed up the labels?</div>'
//         });
        
        var elementOverlays = [];
        var overlaysVisible = true;

        var elements = elementRegistry.getAll();
        for (var elementCount in elements) {
            var elementObject = elements[elementCount];
            if (elementObject.businessObject.$instanceOf('bpmn:FlowNode') || elementObject.businessObject.$instanceOf('bpmn:Participant')) {
                addStyle(elementObject);
            }
        }
        
        function addStyle(element) {

            if (elementOverlays[element.id] !== undefined && elementOverlays[element.id].length !== 0) {
                for (var overlay in elementOverlays[element.id]) {
                    overlays.remove(elementOverlays[element.id][overlay]);
                }
            }

            elementOverlays[element.id] = [];

            if( element.businessObject.documentation !== undefined &&
                element.businessObject.documentation.length > 0 &&
                element.businessObject.documentation[0].text.trim() !== "" &&
                element.type !== "label"){

                var text = element.businessObject.documentation[0].text;
                text = text.replace(/(?:\r\n|\r|\n)/g, '<br />');


                elementOverlays[element.id].push(
                overlays.add(element, 'badge', {
                    position: {
                        top: 4,
                        right: 4
                    },
                    html: '<div class="doc-val-true" data-badge="D"></div><div class="doc-val-hover" data-badge="D">'+text+'</div>'
                }));
            }

            if (element.businessObject.extensionElements === undefined && element.businessObject.$instanceOf('bpmn:FlowNode')) {
                return;
            }

            //Do not process the label of an element
            if (element.type === "label") {
                return;
            }

            var badges = [];

            if(element.businessObject.$instanceOf('bpmn:Participant')) {
                var extensionElements = element.businessObject.processRef.extensionElements;
                var extensions = (extensionElements === undefined ? [] : extensionElements.values);

                var type = '&#9654;';
                var background = 'badge-green';
                if(element.businessObject.processRef.isExecutable === false) {
                    type = '&#10074;&#10074;';
                    background = 'badge-red';
                }
                badges.push({
                    badgeKey: 'isExecutable',
                    badgeSort: 0,
                    badgeType: type,
                    badgeBackground: background,
                    badgeLocation: 'left'
                });
            }
            else {
                var extensions = element.businessObject.extensionElements.values;
            }


            for (var extension in extensions) {
                var type = '';
                var background = '';
                var location = 'right';
                var sort = 0;
                var key = '';

                console.log('Extension: ', extensions[extension])
                
                switch (extensions[extension].$type) {
                    case 'camunda:executionListener':
                        if (extensions[extension].event === 'start') {
                            location = 'left';
                            key = 'camunda:ExecutionListener-start';
                            sort = 20;
                        } else {
                            location = 'right';
                            key = 'camunda:ExecutionListener-end';
                            sort = 70;
                        }
                        type = 'L';
                        background = 'badge-green';
                        break;
                    case 'camunda:properties':
                        key = 'camunda:Properties';
                        sort = 80;
                        type = 'E';
                        background = 'badge-violet';
                        break;
                    case 'camunda:taskListener':
                    	  console.log('task listener detected')
                        if (extensions[extension].event === 'create' || extensions[extension].event === 'assignment') {
                            location = 'left';
                            key = 'camunda:TaskListener-start';
                            sort = 21;
                        } else {
                            location = 'right';
                            key = 'camunda:TaskListener-end';
                            sort = 71;
                        }
                        type = 'T';
                        background = 'badge-green';
                        break;
                    case 'camunda:inputOutput':
                        background = 'badge-blue';
                        break;
                    case 'camunda:in':
                        type = 'V';
                        key = 'camunda:In';
                        location = 'left';
                        sort = 10;
                        background = 'badge-blue';
                        break;
                    case 'camunda:out':
                        type = 'V';
                        key = 'camunda:Out';
                        location = 'right';
                        sort = 60;
                        background = 'badge-blue';
                        break;
                    case 'camunda:field':
                        key = 'camunda:Field';
                        sort = 90;
                        type = 'F';
                        background = 'badge-red';
                        break;
                }

                if (extensions[extension].$type === 'camunda:inputOutput') {
                	  console.log('hasownproperty(inputProperties)', extensions[extension].hasOwnProperty('inputParameters'))
                	  
                    if (extensions[extension].hasOwnProperty('inputParameters') &&
                        extensions[extension].inputParameters.length > 0) {
                        location = 'left';
                        type = 'I';
                        key = 'camunda:InputOutput-input';
                        sort = 10;

                        badges.push({
                            badgeKey: key,
                            badgeSort: sort,
                            badgeType: type,
                            badgeBackground: background,
                            badgeLocation: location
                        });
                    }

                    if (extensions[extension].hasOwnProperty('outputParameters') &&
                        extensions[extension].outputParameters.length > 0) {
                        location = 'right';
                        type = 'O';
                        key = 'camunda:InputOutput-output';
                        sort = 60;

                        badges.push({
                            badgeKey: key,
                            badgeSort: sort,
                            badgeType: type,
                            badgeBackground: background,
                            badgeLocation: location
                        });
                    }
                } else {
                    if (key !== '') {
                        badges.push({
                            badgeKey: key,
                            badgeSort: sort,
                            badgeType: type,
                            badgeBackground: background,
                            badgeLocation: location
                        });
                    }
                }


            }

            addOverlays(badges, element);
        }

        function addOverlays(badgeList, element) {
            var badges = [];

            var leftCounter = 0;
            var rightCounter = 0;


            var sortedBadgeList = uniqBy(badgeList, function (item) {
                return item.badgeKey
            });

            sortedBadgeList.sort(function (a, b) {
                return a.badgeSort - b.badgeSort;
            });

            for (var overlayCounter in sortedBadgeList) {
                var overlayObject = sortedBadgeList[overlayCounter];

                if (overlayObject.badgeLocation === 'left') {
                	  console.log('add left badge')
                    badges.push(overlays.add(element, 'badge', {
                        position: {
                            bottom: 0,
                            left: leftCounter
                        },
                        html: '<div class="badge ' + overlayObject.badgeBackground + '" data-badge="' + overlayObject.badgeType + '"></div>'
                    }));
                    leftCounter = leftCounter + 16;
                } else {
                	  console.log('add right badge')
                    badges.push(overlays.add(element, 'badge', {
                        position: {
                            bottom: 0,
                            right: rightCounter
                        },
                        html: '<div class="badge ' + overlayObject.badgeBackground + '" data-badge="' + overlayObject.badgeType + '"></div>'
                    }));
                    rightCounter = rightCounter + 16;
                }

            }

            pushArray(elementOverlays[element.id],badges);
        }

        function uniqBy(a, key) {
            var seen = {};
            return a.filter(function (item) {
                var k = key(item);
                return seen.hasOwnProperty(k) ? false : (seen[k] = true);
            })
        }

        function pushArray(list, other) {
            var len = other.length;
            var start = list.length;
            list.length = start + len;
            for (var i = 0; i < len; i++ , start++) {
                list[start] = other[i];
            }
        }
        
      } catch (err) {

        console.error('could not import BPMN 2.0 diagram', err);
      }
    }

    // load first diagram from uploaded files
    const reader = new FileReader();
    reader.onload = openDiagram;
    
    if (fileUpload.files.length > 0) {
    	reader.readAsText(fileUpload.files[0]);
    }
    
    fileUpload.addEventListener("change", () => { 
        if (fileUpload.files.length != 0) {
            reader.readAsText(fileUpload.files[0]);
        }
    });

</script>
</body>
</html>